# 跨服务跨库的分布式事务

跨服务，跨数据库的分布式事务，这类分布式事务只是部分遵循 ACID 规范的：

- 原子性：严格遵循
- 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽
- 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽
- 持久性：严格遵循

这里面一致性和隔离性都没有严格遵守，但是 ACID 这四个特性中，AID 这三个特性其实是数据库实现的人非常关心，而对于使用数据库的人，最终的用户，最关心的则是 C，即用户视角看，分布式事务的一致性是什么样的？对于这里面的 C（一致性），我们以一个非常具体的业务例子，来进行解释。假如我们正在处理一个转账业务，假设是 A 转给 B 30 元，在本地事务的支持下，我们的用户看到 A+B 的总金额，在整个转账前后，以及转账过程中，都是保持不变的。那么这个时候用户认为他看到的数据是一致的，符合业务约束的。

当我们业务变复杂，引入多个数据库和大量微服务时，上述本地事务的一致性，依旧是业务非常关心。假如一个业务更新操作，跨库或者跨服务时，那么此时业务关心的一致性问题，就变成了 分布式事务中的一致性问题。在单机本地事务中，A+B 的总金额在任何时刻去查（以常见的 ReadCommitted 或 ReadRepeatable 隔离级别），都是不变的，也就是业务约束一直都保持的这种一致性，我们称之为强一致性。

# 无法强一致

目前在跨库、跨服务的分布式实际应用中，尚未看到有强一致性的方案。我们来看看一致性级别最高的 XA 事务，是否是强一致的，我们以跨行转账（在这里，我们以跨库更新 AB 来模拟）作为例子来说明，下面是一个 XA 事务的时序图：

![XA 事务时序图](https://pic.imgdb.cn/item/61f50f232ab3f51d9142da1b.png)

在这个时序图中，我们在如图所示的时间点发起查询，就是在两个 commit 中间进行的查询，那么我们查到的结果数据，将是 A+B+30，不等于 A+B，不符合强一致的要求。从理论上分析，由于是分布式系统，那么一定是无法保证两个 commit 同时结束，只要两个 commit 中间有时间差，那么无论如何我们都无法保证强一致性。

# 理论上的强一致性

我们接下来思考，普通 XA 事务不是强一致的，但假如完全不考虑性能因素，有没有可能在理论上做到强一致：我们先看看如果我们把 XA 事务涉及的数据库，隔离级别设定到 Serializable，是否能到到强一致的效果呢？我们来看看前面的时序场景：
